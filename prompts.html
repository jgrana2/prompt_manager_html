<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LLM Prompt Manager</title>
  <link rel="stylesheet" href="https://cdn.tailwindcss.com"/>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&family=Nunito:wght@400;600&display=swap" rel="stylesheet"/>
  <style>
    
    /* Hide delete button by default, show on li hover */
    .delete-btn {
      display: none;
    }
    li:hover .delete-btn {
      display: inline-block;
    }
    /* Style for message containers */
    .message {
      margin-bottom: 1rem;
    }
    .user-message {
      text-align: right;
    }
    .assistant-message {
      text-align: left;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
  <header class="px-4 py-2 flex justify-between items-center bg-white shadow">
    <h1 class="text-xl font-bold">LLM Prompt Manager</h1>
    <button id="new-prompt-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
      New Prompt
    </button>
  </header>

  <div class="flex flex-col md:flex-row flex-1 overflow-hidden">
    <!-- Sidebar -->
    <aside class="w-full md:w-1/4 bg-white shadow p-4 overflow-y-auto">
      <h2 class="text-lg font-bold mb-4">Saved Prompts:</h2>
      <div class="relative">
        <input 
          id="search-bar" 
          type="text" 
          placeholder="Search prompts..." 
          class="w-full p-2 pr-8 mb-4 border border-gray-300 rounded" 
        />
        <button id="clear-search" class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700 hidden">
          &times;
        </button>
      </div>
      <ul class="list-none divide-y divide-gray-200" id="prompt-list"></ul>
    </aside>

    <!-- Main Content -->
    <main class="w-full md:flex-1 p-6 overflow-y-auto">
      <div id="initial-instruction" class="text-gray-500 text-center mt-20">
        Select a prompt on the left to start...
      </div>

      <div id="content-container" class="hidden">
        <section class="bg-white shadow rounded p-4 mb-6">
          <h2 class="text-lg font-bold mb-4">Prompt Details:</h2>
          <div id="prompt-display" class="whitespace-pre-wrap text-gray-800"></div>
        </section>

        <section class="bg-white shadow rounded p-4 mb-6">
          <h2 class="text-lg font-bold mb-2">Your Input:</h2>
          <p class="text-sm text-gray-500 mb-4">Press Enter to run the prompt and Shift+Enter to create a new line.</p>
          <div id="input-container" class="space-y-4">
            <!-- Dynamic input sections will be appended here -->
          </div>
        </section>

        <section id="conversation" class="space-y-4">
          <!-- Conversation messages will be appended here -->
        </section>
      </div>
    </main>
  </div>

  <!-- Modal for New Prompt -->
  <div id="new-prompt-modal" class="fixed inset-0 bg-gray-800 bg-opacity-50 flex items-center justify-center hidden">
    <div class="bg-white rounded shadow-lg p-6 w-11/12 md:w-1/3">
      <h3 class="text-xl font-bold mb-4">New Prompt</h3>
      <textarea id="new-prompt-text" class="w-full p-2 border border-gray-300 rounded mb-4" rows="4" placeholder="Enter new prompt here..."></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-btn" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Cancel</button>
        <button id="save-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Save</button>
      </div>
    </div>
  </div>

  <script src="config.js"></script>
  <script>
    // Element references
    const promptList = document.getElementById('prompt-list');
    const searchBar = document.getElementById('search-bar');
    const clearSearchBtn = document.getElementById('clear-search');
    const newPromptBtn = document.getElementById('new-prompt-btn');
    const newPromptModal = document.getElementById('new-prompt-modal');
    const cancelBtn = document.getElementById('cancel-btn');
    const saveBtn = document.getElementById('save-btn');
    const newPromptText = document.getElementById('new-prompt-text');
    const promptDisplay = document.getElementById('prompt-display');
    const inputContainer = document.getElementById('input-container');
    const conversation = document.getElementById('conversation');
    const initialInstruction = document.getElementById('initial-instruction');
    const contentContainer = document.getElementById('content-container');

    const OPENAI_API_KEY = window.OPENAI_API_KEY;
    const OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";

    let messages = [];

    function loadStoredPrompts() {
      const stored = localStorage.getItem('savedPrompts');
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch (e) {
          console.error('Error parsing stored prompts:', e);
        }
      }
      return [];
    }

    function savePrompts(prompts) {
      localStorage.setItem('savedPrompts', JSON.stringify(prompts));
    }

    let prompts = loadStoredPrompts();

    function createPromptListItem(text) {
      const li = document.createElement('li');
      li.className = "py-2 flex justify-between items-center cursor-pointer hover:bg-gray-100";
      li.setAttribute('data-prompt', text);

      const span = document.createElement('span');
      span.textContent = text.length > 40 ? text.slice(0, 40) + '...' : text;
      li.appendChild(span);

      const deleteBtn = document.createElement('button');
      deleteBtn.className = "delete-btn text-red-500 hover:text-red-700";
      deleteBtn.title = "Delete Prompt";
      deleteBtn.textContent = "🗑️";
      li.appendChild(deleteBtn);

      attachPromptClickHandler(li);

      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const promptToDelete = li.getAttribute('data-prompt');
        li.remove();
        prompts = prompts.filter(p => p !== promptToDelete);
        savePrompts(prompts);
      });

      return li;
    }

    prompts.forEach(text => {
      const li = createPromptListItem(text);
      promptList.appendChild(li);
    });

    function attachPromptClickHandler(item) {
      item.addEventListener('click', function() {
        if (initialInstruction.style.display !== 'none') {
          initialInstruction.style.display = 'none';
          contentContainer.classList.remove('hidden');
        }

        inputContainer.innerHTML = '';
        conversation.innerHTML = '';
        messages = [];

        const promptText = this.getAttribute('data-prompt');
        promptDisplay.textContent = promptText;

        const inputRegex = /\${input\s*\d+}/g;
        const inputsFound = promptText.match(inputRegex);

        if (inputsFound) {
          inputsFound.forEach((placeholder, index) => {
            const inputSection = document.createElement('div');
            inputSection.className = "flex flex-col";

            const label = document.createElement('label');
            label.textContent = placeholder.replace('${', '').replace('}', '').trim();
            label.className = "mb-1 font-semibold";

            const textarea = document.createElement('textarea');
            textarea.className = "w-full p-2 border border-gray-300 rounded text-lg";
            textarea.placeholder = placeholder.replace('${', '').replace('}', '').trim();
            textarea.rows = 2;
            textarea.dataset.index = index;

            textarea.addEventListener('keydown', (e) => {
              if(e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleRun(textarea);
              }
            });

            inputSection.appendChild(label);
            inputSection.appendChild(textarea);
            inputContainer.appendChild(inputSection);
          });
        } else {
          const inputSection = document.createElement('div');
          inputSection.className = "flex flex-col";

          const label = document.createElement('label');
          label.textContent = "Input";
          label.className = "mb-1 font-semibold";

          const textarea = document.createElement('textarea');
          textarea.id = "user-input";
          textarea.className = "w-full p-2 border border-gray-300 rounded text-lg";
          textarea.placeholder = "Enter additional instructions or input...";
          textarea.rows = 2;

          textarea.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              handleRun(textarea);
            }
          });

          inputSection.appendChild(label);
          inputSection.appendChild(textarea);
          inputContainer.appendChild(inputSection);
        }

        // Initialize first input focus
        const firstInput = inputContainer.querySelector('textarea');
        if (firstInput) {
          firstInput.focus();
        }
      });
    }

    async function handleRun(textarea) {
      const runButton = document.createElement('button');
      runButton.className = "bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded";
      runButton.textContent = "Run";
      runButton.disabled = true;

      // Replace textarea with disabled textarea and run button
      const parent = textarea.parentElement;
      parent.replaceChild(runButton, textarea);

      // Gather all inputs
      let promptText = promptDisplay.textContent;
      const inputTexts = inputContainer.querySelectorAll('textarea');
      inputTexts.forEach((input, idx) => {
        const placeholder = input.previousElementSibling.textContent;
        promptText = promptText.replace(`\${input ${idx + 1}}`, input.value.trim());
      });

      // Add user message
      const userMessage = document.createElement('div');
      userMessage.className = "message user-message";
      userMessage.innerHTML = `<div class="inline-block bg-blue-100 text-blue-800 px-4 py-2 rounded-lg"> ${promptText} </div>`;
      conversation.appendChild(userMessage);
      conversation.scrollTop = conversation.scrollHeight;

      messages.push({ role: "user", content: promptText });

      // Send to OpenAI
      try {
        const stream = await sendPromptToOpenAI(messages);
        const reader = stream.getReader();
        await streamResponse(reader, conversation);
      } catch (error) {
        console.error(error);
        const errorMessage = document.createElement('div');
        errorMessage.className = "message assistant-message";
        errorMessage.innerHTML = `<div class="inline-block bg-red-100 text-red-800 px-4 py-2 rounded-lg">Error communicating with OpenAI API.</div>`;
        conversation.appendChild(errorMessage);
        conversation.scrollTop = conversation.scrollHeight;
      }
    }

    async function sendPromptToOpenAI(messages) {
      const requestBody = {
        model: "gpt-4o-mini",
        messages: messages,
        stream: true
      };

      const response = await fetch(OPENAI_API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OPENAI_API_KEY}`
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.statusText}`);
      }

      return response.body;
    }

    function streamResponse(reader, conversation) {
      return new Promise((resolve, reject) => {
        const decoder = new TextDecoder();
        let buffer = '';
        let assistantMessage = document.createElement('div');
        assistantMessage.className = "message assistant-message";
        const contentDiv = document.createElement('div');
        contentDiv.className = "inline-block bg-gray-100 text-gray-800 px-4 py-2 rounded-lg";
        assistantMessage.appendChild(contentDiv);
        conversation.appendChild(assistantMessage);
        conversation.scrollTop = conversation.scrollHeight;

        function read() {
          reader.read().then(({ done, value }) => {
            if (done) {
              resolve();
              return;
            }

            buffer += decoder.decode(value, { stream: true });
            let lines = buffer.split('\n');
            buffer = lines.pop();

            for (let line of lines) {
              line = line.trim();
              if (!line.startsWith('data: ')) continue;

              let jsonStr = line.replace(/^data:\s*/, '');
              if (jsonStr === '[DONE]') {
                resolve();
                return;
              }

              try {
                let parsed = JSON.parse(jsonStr);
                let deltaContent = parsed.choices[0]?.delta?.content;
                if (deltaContent) {
                  contentDiv.textContent += deltaContent;
                  conversation.scrollTop = conversation.scrollHeight;
                }
              } catch (e) {
                console.error('Error parsing JSON:', e);
              }
            }
            read();
          }).catch(error => {
            console.error("Error reading stream:", error);
            reject(error);
          });
        }
        read();
      });
    }

    newPromptBtn.addEventListener('click', () => {
      newPromptModal.classList.remove('hidden');
      newPromptText.focus();
    });

    cancelBtn.addEventListener('click', () => {
      newPromptModal.classList.add('hidden');
      newPromptText.value = '';
    });

    saveBtn.addEventListener('click', () => {
      const text = newPromptText.value.trim();
      if (text) {
        const newLi = createPromptListItem(text);
        promptList.appendChild(newLi);

        prompts.push(text);
        savePrompts(prompts);

        newPromptText.value = '';
        newPromptModal.classList.add('hidden');
      }
    });

    searchBar.addEventListener('input', () => {
      const query = searchBar.value.toLowerCase();
      if (query.length > 0) {
        clearSearchBtn.classList.remove('hidden');
      } else {
        clearSearchBtn.classList.add('hidden');
      }
      document.querySelectorAll('#prompt-list li').forEach(li => {
        const text = li.getAttribute('data-prompt').toLowerCase();
        li.style.display = text.includes(query) ? '' : 'none';
      });
    });

    clearSearchBtn.addEventListener('click', () => {
      searchBar.value = '';
      clearSearchBtn.classList.add('hidden');
      document.querySelectorAll('#prompt-list li').forEach(li => {
        li.style.display = '';
      });
      searchBar.focus();
    });

  </script>

  <style>
    @import "https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css";
    body { font-family: 'Nunito', sans-serif; }
    #conversation {
      max-height: 60vh;
      overflow-y: auto;
    }
  </style>
</body>
</html>